#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
parts.json + per-part mesh files -> assembly.glb (with per-part nodes) + node_map.json

- Reads parts.json generated by step_to_parts.py
- Loads each meshPath (stl/obj/ply) using trimesh
- Adds each part as a separate node in a trimesh.Scene
  - node name is fixed to partKey by default (recommended)
- Exports one GLB (assembly.glb)
- Writes a node_map.json:
  [
    {
      "partKey": "...",
      "nodeName": "...",
      "nodePath": "...",
      "parentKey": "...",
      "nodeIndex": 12,   # optional (filled when --write-node-index and available)
      "meshPath": "...",
      "position": [...],
      "size": [...]
    }, ...
  ]

Usage:
  python parts_to_glb.py --parts-json <parts.json> --out-glb <assembly.glb> --out-map <node_map.json>

Optional:
  --node-name partKey|name|safeName   (default partKey)
  --write-node-index                  (try to fill nodeIndex by reading exported glb)
  --quiet
"""

import os
import sys
import json
import argparse
import traceback

def _safe_node_name(s: str) -> str:
    if s is None:
        return "part"
    s = str(s).strip()
    # glTF node names can contain many chars, but keep it safe for tooling
    return s.replace("\\", "_").replace("/", "_") or "part"

def parse_args(argv):
    p = argparse.ArgumentParser(add_help=True)
    p.add_argument("--parts-json", required=True, help="Path to parts.json (from step_to_parts.py)")
    p.add_argument("--out-glb", required=True, help="Output GLB file path (assembly.glb)")
    p.add_argument("--out-map", required=True, help="Output mapping json path (node_map.json)")
    p.add_argument("--node-name", default="partKey", choices=["partKey", "name", "safeName"],
                   help="What to use as GLB node name per part (default: partKey)")
    p.add_argument("--write-node-index", action="store_true",
                   help="Try to fill nodeIndex by reading exported GLB (best-effort).")
    p.add_argument("--quiet", action="store_true", help="Less stderr logs")
    return p.parse_args(argv)

def load_parts(parts_json_path: str):
    with open(parts_json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    parts = data.get("parts")
    if not isinstance(parts, list):
        raise ValueError("parts.json must contain { 'parts': [ ... ] }")

    return parts

def build_scene(parts, node_name_mode: str, quiet: bool):
    # trimesh is the simplest stable way to assemble many meshes into one GLB scene
    import trimesh
    import numpy as np

    scene = trimesh.Scene()
    mapping = []

    for idx, part in enumerate(parts):
        try:
            part_key = part.get("partKey")
            name = part.get("name")
            mesh_path = part.get("meshPath")

            if not mesh_path or not os.path.exists(mesh_path):
                if not quiet:
                    print(f"WARN: meshPath not found, skip: {mesh_path}", file=sys.stderr)
                continue

            # Decide node name
            if node_name_mode == "partKey":
                node_name = _safe_node_name(part_key)
            elif node_name_mode == "name":
                node_name = _safe_node_name(name)
            else:
                # safeName: prefer partKey but shorter fallback
                node_name = _safe_node_name(part_key or name or f"part_{idx}")

            # Load mesh
            loaded = trimesh.load(mesh_path, force="mesh")
            if loaded is None:
                if not quiet:
                    print(f"WARN: failed to load mesh, skip: {mesh_path}", file=sys.stderr)
                continue

            # Ensure we have a Trimesh (sometimes returns Scene)
            if isinstance(loaded, trimesh.Scene):
                # Merge scene geometries into one (still under one part node)
                meshes = []
                for g in loaded.geometry.values():
                    if isinstance(g, trimesh.Trimesh):
                        meshes.append(g)
                if not meshes:
                    continue
                mesh = trimesh.util.concatenate(meshes)
            else:
                mesh = loaded

            # Basic sanity
            if not isinstance(mesh, trimesh.Trimesh):
                continue
            if mesh.vertices is None or len(mesh.vertices) == 0:
                continue

            # Transform:
            # IMPORTANT: The STL exported by FreeCAD from original shapes is already in assembly coordinates,
            # so identity transform usually keeps assembly correct.
            # (If you later find alignment issues, this is where you'd apply transforms.)
            transform = np.eye(4)

            # Add as separate node
            # geometry name should be unique to avoid unexpected merges in exporters
            geom_name = f"geom_{idx}"
            scene.add_geometry(mesh, node_name=node_name, geom_name=geom_name, transform=transform)

            mapping.append({
                "partKey": part_key,
                "nodeName": node_name,
                "nodePath": part.get("nodePath"),
                "parentKey": part.get("parentKey"),
                "nodeIndex": None,  # filled later best-effort
                "meshPath": mesh_path.replace("\\", "/"),
                "position": part.get("position"),
                "size": part.get("size"),
            })

        except Exception as e:
            if not quiet:
                print(f"WARN: part build failed idx={idx}: {e}", file=sys.stderr)
            continue

    return scene, mapping

def export_glb(scene, out_glb_path: str):
    import trimesh

    os.makedirs(os.path.dirname(out_glb_path), exist_ok=True)
    # trimesh will export a GLB containing a glTF scene with nodes per geometry added above
    glb_bytes = scene.export(file_type="glb")
    if not isinstance(glb_bytes, (bytes, bytearray)):
        # Some versions return a file path; normalize
        raise RuntimeError("Unexpected trimesh export result (expected bytes).")

    with open(out_glb_path, "wb") as f:
        f.write(glb_bytes)

def try_fill_node_index(out_glb_path: str, mapping, quiet: bool):
    """
    Best-effort nodeIndex fill:
    - If pygltflib is available, read nodes array and match by node.name == mapping.nodeName
    - If not available, keep nodeIndex None (still OK: nodeName mapping is sufficient)
    """
    try:
        from pygltflib import GLTF2  # optional dependency
    except Exception:
        if not quiet:
            print("INFO: pygltflib not installed; nodeIndex will remain null (nodeName mapping is still OK).",
                  file=sys.stderr)
        return mapping

    try:
        gltf = GLTF2().load(out_glb_path)
        nodes = gltf.nodes or []
        name_to_index = {}
        for i, n in enumerate(nodes):
            if n and getattr(n, "name", None):
                name_to_index[str(n.name)] = i

        for m in mapping:
            nm = m.get("nodeName")
            if nm in name_to_index:
                m["nodeIndex"] = int(name_to_index[nm])

        return mapping
    except Exception as e:
        if not quiet:
            print(f"WARN: failed to fill nodeIndex: {e}", file=sys.stderr)
        return mapping

def main():
    args = parse_args(sys.argv[1:])

    parts_json_path = args.parts_json
    out_glb_path = args.out_glb
    out_map_path = args.out_map
    quiet = bool(args.quiet)

    if not os.path.exists(parts_json_path):
        print(f"ERROR: parts.json not found: {parts_json_path}", file=sys.stderr)
        sys.exit(2)

    try:
        parts = load_parts(parts_json_path)
        if len(parts) == 0:
            print("ERROR: parts.json has no parts.", file=sys.stderr)
            sys.exit(4)

        scene, mapping = build_scene(parts, args.node_name, quiet)
        if len(mapping) == 0:
            print("ERROR: no valid meshes loaded from parts.json.", file=sys.stderr)
            sys.exit(5)

        export_glb(scene, out_glb_path)

        if args.write_node_index:
            mapping = try_fill_node_index(out_glb_path, mapping, quiet)

        os.makedirs(os.path.dirname(out_map_path), exist_ok=True)
        with open(out_map_path, "w", encoding="utf-8") as f:
            json.dump(mapping, f, ensure_ascii=False, indent=2)

        if not quiet:
            print(f"OK: glb={out_glb_path}")
            print(f"OK: map={out_map_path}")
            print(f"OK: parts={len(mapping)}")

    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        if not quiet:
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
