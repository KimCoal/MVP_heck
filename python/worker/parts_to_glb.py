#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""\
parts.json + per-part mesh files -> assembly.glb (with per-part nodes) + node_map.json

- Reads parts.json generated by step_to_parts.py
- Loads each meshPath (stl/obj/ply) using trimesh
- Adds each part as a separate node in a trimesh.Scene
  - node name is fixed to partKey by default (recommended)
- Exports one GLB (assembly.glb)
- Writes a node_map.json:
  [
    {
      "partKey": "...",
      "nodeName": "...",
      "nodePath": "...",
      "parentKey": "...",
      "nodeIndex": 12,
      "meshPath": "...",
      "position": [...],
      "size": [...]
    }, ...
  ]

Why this file was patched:
- Some STEP assemblies contain control characters in part names/node paths.
- Even if we don't use "name" as GLB nodeName (we default to partKey),
  the mapping JSON can still carry those strings.
- We sanitize node names/strings to remove C0/C1 control chars.
"""

import os
import sys
import json
import argparse
import traceback
import re
import unicodedata

# ----------
# Text sanitation
# ----------
_CTRL_RE = re.compile(r"[\x00-\x1F\x7F-\x9F]")


def clean_text(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = unicodedata.normalize("NFKC", s)
    s = _CTRL_RE.sub("", s)
    s = s.replace("\uFFFD", "")
    return s.strip()


def _safe_node_name(s: str) -> str:
    if s is None:
        return "part"
    s = clean_text(s)
    return (s.replace("\\", "_").replace("/", "_") or "part")


def parse_args(argv):
    p = argparse.ArgumentParser(add_help=True)
    p.add_argument("--parts-json", required=True, help="Path to parts.json (from step_to_parts.py)")
    p.add_argument("--out-glb", required=True, help="Output GLB file path (assembly.glb)")
    p.add_argument("--out-map", required=True, help="Output mapping json path (node_map.json)")
    p.add_argument("--node-name", default="partKey", choices=["partKey", "name", "safeName"],
                   help="What to use as GLB node name per part (default: partKey)")
    p.add_argument("--write-node-index", action="store_true",
                   help="Try to fill nodeIndex by reading exported GLB (best-effort).")
    p.add_argument("--quiet", action="store_true", help="Less stderr logs")
    return p.parse_args(argv)


def load_parts(parts_json_path: str):
    with open(parts_json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    parts = data.get("parts")
    if not isinstance(parts, list):
        raise ValueError("parts.json must contain { 'parts': [ ... ] }")

    return parts


def build_scene(parts, node_name_mode: str, quiet: bool):
    import trimesh
    import numpy as np

    scene = trimesh.Scene()
    mapping = []

    for idx, part in enumerate(parts):
        try:
            part_key = part.get("partKey")
            name = part.get("name")
            mesh_path = part.get("meshPath")

            if not mesh_path or not os.path.exists(mesh_path):
                if not quiet:
                    print(f"WARN: meshPath not found, skip: {mesh_path}", file=sys.stderr)
                continue

            # Decide node name
            if node_name_mode == "partKey":
                node_name = _safe_node_name(part_key)
            elif node_name_mode == "name":
                node_name = _safe_node_name(name)
            else:
                node_name = _safe_node_name(part_key or name or f"part_{idx}")

            loaded = trimesh.load(mesh_path, force="mesh")
            if loaded is None:
                if not quiet:
                    print(f"WARN: failed to load mesh, skip: {mesh_path}", file=sys.stderr)
                continue

            if isinstance(loaded, trimesh.Scene):
                meshes = []
                for g in loaded.geometry.values():
                    if isinstance(g, trimesh.Trimesh):
                        meshes.append(g)
                if not meshes:
                    continue
                mesh = trimesh.util.concatenate(meshes)
            else:
                mesh = loaded

            if not isinstance(mesh, trimesh.Trimesh):
                continue
            if mesh.vertices is None or len(mesh.vertices) == 0:
                continue

            transform = np.eye(4)
            geom_name = f"geom_{idx}"
            scene.add_geometry(mesh, node_name=node_name, geom_name=geom_name, transform=transform)

            mapping.append({
                "partKey": part_key,
                "nodeName": node_name,
                "nodePath": clean_text(part.get("nodePath")),
                "parentKey": part.get("parentKey"),
                "nodeIndex": None,
                "meshPath": mesh_path.replace("\\", "/"),
                "position": part.get("position"),
                "size": part.get("size"),
            })

        except Exception as e:
            if not quiet:
                print(f"WARN: part build failed idx={idx}: {e}", file=sys.stderr)
            continue

    return scene, mapping


def export_glb(scene, out_glb_path: str):
    os.makedirs(os.path.dirname(out_glb_path), exist_ok=True)
    glb_bytes = scene.export(file_type="glb")
    if not isinstance(glb_bytes, (bytes, bytearray)):
        raise RuntimeError("Unexpected trimesh export result (expected bytes).")

    with open(out_glb_path, "wb") as f:
        f.write(glb_bytes)


def try_fill_node_index(out_glb_path: str, mapping, quiet: bool):
    try:
        from pygltflib import GLTF2
    except Exception:
        if not quiet:
            print("INFO: pygltflib not installed; nodeIndex will remain null (nodeName mapping is still OK).",
                  file=sys.stderr)
        return mapping

    try:
        gltf = GLTF2().load(out_glb_path)
        nodes = gltf.nodes or []
        name_to_index = {}
        for i, n in enumerate(nodes):
            if n and getattr(n, "name", None):
                name_to_index[str(n.name)] = i

        for m in mapping:
            nm = m.get("nodeName")
            if nm in name_to_index:
                m["nodeIndex"] = int(name_to_index[nm])

        return mapping
    except Exception as e:
        if not quiet:
            print(f"WARN: failed to fill nodeIndex: {e}", file=sys.stderr)
        return mapping


def main():
    args = parse_args(sys.argv[1:])

    parts_json_path = args.parts_json
    out_glb_path = args.out_glb
    out_map_path = args.out_map
    quiet = bool(args.quiet)

    if not os.path.exists(parts_json_path):
        print(f"ERROR: parts.json not found: {parts_json_path}", file=sys.stderr)
        sys.exit(2)

    try:
        parts = load_parts(parts_json_path)
        if len(parts) == 0:
            print("ERROR: parts.json has no parts.", file=sys.stderr)
            sys.exit(4)

        scene, mapping = build_scene(parts, args.node_name, quiet)
        if len(mapping) == 0:
            print("ERROR: no valid meshes loaded from parts.json.", file=sys.stderr)
            sys.exit(5)

        export_glb(scene, out_glb_path)

        if args.write_node_index:
            mapping = try_fill_node_index(out_glb_path, mapping, quiet)

        os.makedirs(os.path.dirname(out_map_path), exist_ok=True)
        with open(out_map_path, "w", encoding="utf-8") as f:
            json.dump(mapping, f, ensure_ascii=False, indent=2)

        if not quiet:
            print(f"OK: glb={out_glb_path}")
            print(f"OK: map={out_map_path}")
            print(f"OK: parts={len(mapping)}")

    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        if not quiet:
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
